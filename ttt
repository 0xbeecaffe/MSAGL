diff --git a/GraphLayout/MSAGL/GraphmapsWithMesh/MeshCreator.cs b/GraphLayout/MSAGL/GraphmapsWithMesh/MeshCreator.cs
index a3a8ab1..97723c5 100644
--- a/GraphLayout/MSAGL/GraphmapsWithMesh/MeshCreator.cs
+++ b/GraphLayout/MSAGL/GraphmapsWithMesh/MeshCreator.cs
@@ -532,7 +532,7 @@ public static void FastCompetitionMesh(Tiling g, Dictionary<int, Node> idToNode,
         public static void ProcessLeftRays(Tiling g, Dictionary<int, int> Neighbors4, Dictionary<int, int> Neighbors5, int maxX, int maxY, Dictionary<Point, int> locationtoNode)
         {
             int a;
-            LineSegment l;
+            //LineSegment l;
             for (int i = 0; i < g.N; i++)
             {
                 Vertex CurrentVertex = g.VList[i];
@@ -695,7 +695,7 @@ public static void ProcessLeftRays(Tiling g, Dictionary<int, int> Neighbors4, Di
         public static void ProcessUpwardRays(Tiling g, int maxX, int maxY, Dictionary<Point, int> locationtoNode)
         {
             int a;
-            LineSegment l;
+            //LineSegment l;
 
             //sort all horizontal segments according to the y coordinates
             List<double> Y = new List<double>();
@@ -851,7 +851,7 @@ public static void ProcessUpwardRays(Tiling g, int maxX, int maxY, Dictionary<Po
         public static void ProcessDownwardRays(Tiling g, int maxX, int maxY, Dictionary<Point, int> locationtoNode)
         {
             int a;
-            LineSegment l;
+            //LineSegment l;
 
             //sort all horizontal segments according to the -y coordinates
             List<double> Y = new List<double>();
@@ -997,7 +997,7 @@ public static void ProcessDownwardRays(Tiling g, int maxX, int maxY, Dictionary<
         public static void ProcessRightRays(Tiling g, Dictionary<int, int> Neighbors1, Dictionary<int, int> Neighbors8, int maxX, int maxY, Dictionary<Point, int> locationtoNode)
         {
             int a;
-            LineSegment l;
+            //LineSegment l;
             for (int i = 0; i < g.N; i++)
             {
                 Vertex CurrentVertex = g.VList[i];
diff --git a/GraphLayout/MSAGL/GraphmapsWithMesh/PlanarGraphUtilities.cs b/GraphLayout/MSAGL/GraphmapsWithMesh/PlanarGraphUtilities.cs
index 93242f0..d47cd5f 100644
--- a/GraphLayout/MSAGL/GraphmapsWithMesh/PlanarGraphUtilities.cs
+++ b/GraphLayout/MSAGL/GraphmapsWithMesh/PlanarGraphUtilities.cs
@@ -106,7 +106,7 @@ public static List<Vertex> GetRightIncidentFace(Tiling gPlanar, Vertex givenTail
         public static void RemoveLongEdgesFromThinFaces(Tiling gPlanar)
         {
             Console.WriteLine("Removing Thin Faces");
-            bool searchFurther = true;
+            //bool searchFurther = true;
             //while (searchFurther)
             //{
             //you need to handle face one after another - since you are changing the adjacency list
diff --git a/GraphLayout/MSAGL/GraphmapsWithMesh/PointSet.cs b/GraphLayout/MSAGL/GraphmapsWithMesh/PointSet.cs
index c708c4c..147f5b2 100644
--- a/GraphLayout/MSAGL/GraphmapsWithMesh/PointSet.cs
+++ b/GraphLayout/MSAGL/GraphmapsWithMesh/PointSet.cs
@@ -53,7 +53,6 @@ public bool isVeryClose(int x, int y, int n)
 
         public bool exists(int x, int y, int n)
         {
-            double d;
             for (int i = NumPoints - 1; i > n; i--)
             {
                 if (Pt[i].X == x && Pt[i].Y == y) return true;
diff --git a/GraphLayout/MSAGL/GraphmapsWithMesh/SteinerTree.cs b/GraphLayout/MSAGL/GraphmapsWithMesh/SteinerTree.cs
index 50ee111..4689991 100644
--- a/GraphLayout/MSAGL/GraphmapsWithMesh/SteinerTree.cs
+++ b/GraphLayout/MSAGL/GraphmapsWithMesh/SteinerTree.cs
@@ -7,7 +7,7 @@ class SteinerTree
     {
         public Stack<Tuple> Edgelist = new Stack<Tuple>();
         public List<Twin> SpanningTree = new List<Twin>();
-        ComponentCollection _compCollection;
+        //ComponentCollection _compCollection;
  
 
     }
diff --git a/GraphLayout/MSAGL/GraphmapsWithMesh/Tiling.cs b/GraphLayout/MSAGL/GraphmapsWithMesh/Tiling.cs
index 40febb6..a7e28d2 100644
--- a/GraphLayout/MSAGL/GraphmapsWithMesh/Tiling.cs
+++ b/GraphLayout/MSAGL/GraphmapsWithMesh/Tiling.cs
@@ -287,7 +287,6 @@ public void MsaglMoveToMaximizeMinimumAngle()
                     Vertex w = VList[index];
 
                     int numNeighbors = 0;
-                    double cost = 100000;
                     double profit = 0;
 
                     for (int k = 0; k < DegList[w.Id]; k++)
@@ -330,7 +329,7 @@ public void MsaglMoveToMaximizeMinimumAngle()
                                 break;
                             }
 
-                            ///*try to maximize min angle
+                            // *try to maximize min angle
                             d[counter] = 3.1416;
                             for (int l = 1; l <= numNeighbors; l++)
                             {
@@ -350,7 +349,7 @@ public void MsaglMoveToMaximizeMinimumAngle()
                             //*/
 
                         }
-                        ///*try to maximize min angle
+                        // *try to maximize min angle
                         if (profit < d[counter])
                         {
                             profit = d[counter]; mincostA = a; mincostB = b;
diff --git a/GraphLayout/MSAGL/Layout/LargeGraphLayout/LgInteractor.cs b/GraphLayout/MSAGL/Layout/LargeGraphLayout/LgInteractor.cs
index b17b628..b2b8560 100644
--- a/GraphLayout/MSAGL/Layout/LargeGraphLayout/LgInteractor.cs
+++ b/GraphLayout/MSAGL/Layout/LargeGraphLayout/LgInteractor.cs
@@ -15,6 +15,7 @@
 using Microsoft.Msagl.Core.Layout;
 using Microsoft.Msagl.Core.Layout.ProximityOverlapRemoval.MinimumSpanningTree;
 using Microsoft.Msagl.Core.Routing;
+using Microsoft.Msagl.DebugHelpers;
 using Microsoft.Msagl.GraphmapsWithMesh;
 using Microsoft.Msagl.Layout.Incremental;
 using Microsoft.Msagl.Layout.Initial;
@@ -407,7 +408,7 @@ public void DrawAtEachLevelQuotaBounded(Tiling[] g, Dictionary<Node, int> nodeTo
 
             //until all edges are added create a layer and add vertices one after another
             int layer = 0;
-            int plottedNodeCount = 0;
+            //int plottedNodeCount = 0;
             List<Node> nodes = new List<Node>();
             _lgData.Levels.Clear();
              
@@ -680,7 +681,7 @@ public bool loadBipartiteData()
             {
                 System.IO.StreamReader file = new System.IO.StreamReader(line + ".set");
                 Dictionary<string, int> nametoset = new Dictionary<string, int>();
-                int count = 0;
+                //int count = 0;
                 while ((line = file.ReadLine()) != null)
                 {
                     string[] words = line.Split(',');
@@ -697,6 +698,7 @@ public bool loadBipartiteData()
             }
             catch (Exception e)
             {
+                Console.WriteLine(e.Message);
                 Console.WriteLine("May not be a Bipartite Graph");
                 return false;
             }
@@ -723,7 +725,6 @@ public bool LoadNodeLocationsFromFile()
             {
                 System.IO.StreamReader file = new System.IO.StreamReader(line+".loc");
                 Dictionary<string, Point> nametopoint = new Dictionary<string, Point>();
-                int count = 0;
                 while ((line = file.ReadLine()) != null)
                 {
                     string[] words = line.Split(',');
@@ -754,6 +755,7 @@ public bool LoadNodeLocationsFromFile()
             }
             catch (Exception e)
             {                
+                Console.WriteLine(e.Message);
                 Console.WriteLine("No prespecified location found.");
                 return false;
             }
@@ -1006,7 +1008,7 @@ private Tiling ComputeEdgeRoutes(Tiling g, Dictionary<Node, int> nodeId, Diction
 
         public Dictionary<SymmetricSegment, Rail> Segs = new Dictionary<SymmetricSegment, Rail>();
 
-        GreedyNodeRailLevelCalculator calc;
+        //GreedyNodeRailLevelCalculator calc;
 
         public int[] graphLayer = new int[100];
 
@@ -1387,7 +1389,7 @@ private void FillGeometryNodesToLgNodeInfos()
         /// </summary>
         public void Run()
         {
-            Dictionary<Node, int> nodeToIndex;
+            //Dictionary<Node, int> nodeToIndex;
 
 
             Console.WriteLine("dot graph");
@@ -2171,7 +2173,7 @@ public void RouteEdgesOnZeroLayer()
             var skeletonLevel = _lgData.SkeletonLevels[0];
             skeletonLevel.ClearSavedTrajectoriesAndUsedEdges();
             Console.Write("\nRouting edges");
-            int numRouted = 0;
+            //int numRouted = 0;
 
             foreach (LgNodeInfo ni in GetNodeInfosOnLevelLeq(0))
             {
diff --git a/GraphLayout/MSAGL/Layout/LargeGraphLayout/Rail.cs b/GraphLayout/MSAGL/Layout/LargeGraphLayout/Rail.cs
index e3654f9..b33bd7e 100644
--- a/GraphLayout/MSAGL/Layout/LargeGraphLayout/Rail.cs
+++ b/GraphLayout/MSAGL/Layout/LargeGraphLayout/Rail.cs
@@ -7,6 +7,7 @@
 using Microsoft.Msagl.Core.Geometry.Curves;
 using Microsoft.Msagl.Core.Layout;
 using Microsoft.Msagl.Routing.Visibility;
+using LineSegment = Microsoft.Msagl.Core.Geometry.Curves.LineSegment;
 
 namespace Microsoft.Msagl.Layout.LargeGraphLayout {
 
